# PHP面向对象

PHP通过Class关键字定义类，通过new 关键字创建对象，类最重要的两个最重要的组成部分是属性和方法

```php
//定义一个类
class Computer{

}
//通过new关键字生成对象，完成实例化
$pc=new Computer();
var_dump($computer);
```

通过php命令在控制台运行，得到结果

```php
object(Computer)#1 (0) {
}
```





## PHP 类的属性

PHP 通过$符号声明属性，类的属性有三种访问控制 分别为

> + public 公有的 可以在任何地方被访问 
> + private 私有的，只有类自身可以访问
> + protected 受保护的，可以被类自身以及其子类访问

类的属性访问控制必须声明，不可缺少。

```php
<?php
    //定义一个类
    class Computer{
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被访问 
        * private 私有的，只有自身可以访问
        * protected 受保护的，只有自身以及其父类和子类可以访问
        */
        
        public $cpu='amd';
        private $motherboard='华硕主板';
        protected $memory='海盗船';
        
    }
    //使用new关键字生成对象
    $computer=new Computer();
    
    var_dump($computer);
    var_dump($computer->cpu);
    var_dump($computer->motherboard);
    //var_dump($computer->memory);
```

运行结果如下：

```bash
object(Computer)#1 (3) {
  ["cpu"]=>
  string(3) "amd"
  ["motherboard":"Computer":private]=>
  string(12) "华硕主板"
  ["memory":protected]=>
  string(9) "海盗船"
}
string(3) "amd"

Fatal error: Uncaught Error: Cannot access private property Computer::$motherboa
rd in C:\php_learn\sample\1.php:22
Stack trace:
#0 {main}
  thrown in C:\php_learn\sample\1.php on line 22

```



```php
<?php
    //定义一个类
    class Computer{
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被访问 
        * private 私有的，只有自身可以访问
        * protected 受保护的，只有自身以及其父类和子类可以访问
        */
        
        public $cpu='amd';
        private $motherboard='华硕主板';
        protected $memory='海盗船';
        
    }
    //使用new关键字生成对象
    $computer=new Computer();
    
    var_dump($computer);
    var_dump($computer->cpu);
    //var_dump($computer->motherboard);
    var_dump($computer->memory);
```



运行结果：

```bash
object(Computer)#1 (3) {
  ["cpu"]=>
  string(3) "amd"
  ["motherboard":"Computer":private]=>
  string(12) "华硕主板"
  ["memory":protected]=>
  string(9) "海盗船"
}
string(3) "amd"

Fatal error: Uncaught Error: Cannot access protected property Computer::$memory in C:\php_learn\sample\1.p
hp:23
Stack trace:
#0 {main}
  thrown in C:\php_learn\sample\1.php on line 23

```



可以看到访问控制为private 和protected属性在外部被访问时会抛出错误。

## PHP 类的方法

PHP 类的方法和函数的声明类似，不过方法具有访问控制，方法的访问控制和属性类似

> + public 公有的方法 可以在任何地方被访问 
> + private 私有方法，只有类自身可以访问
> + protected 受保护的方法，可以被类自身以及其子类访问

在类的内部，通过this关键字访问自身属性和调用方法，$this表示当前实例，在类的内部方法访问未声明为const及static的属性时，使用$this

```php
<?php
    //定义一个类
    class Computer{
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被访问 
        * private 私有的，只有自身可以访问
        * protected 受保护的，只有自身以及其父类和子类可以访问
        */
        
        public $cpu='amd';
        private $motherboard='华硕主板';
        protected $memory='海盗船';
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被调用 
        * private 私有的，只有自身可以调用
        * protected 受保护的，只有自身以及其父类和子类可以调用
        */
        
        //
        public function getCPU(){
            //在类的内部，通过$this关键字访问属性，$this表示当前实例，指向当前对象本身
            return $this->cpu;
        }
        
        public function showCPU(){
            //在类的内部，通过$this关键字调用方法
            echo 'CPU型号:'.$this->getCPU();
        }
        
    }
    //使用new关键字生成对象
    $computer=new Computer();
    
    var_dump($computer->getCPU());
    $computer->showCPU();
```

输出结果：

```bash
string(3) "amd"
CPU型号:amd
```



## 类的构造方法和析构方法

PHP的类有两个内置方法： 构造方法 `__construct` 析构方法 `__destruct`

构造方法会在对象初始化时被自动调用，析构方法会在对象被销毁时自动调用。所以通常可以在构造方法里来完成一些初始化的操作，而不需要人为调用。

```php
<?php
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被访问 
        * private 私有的，只有自身可以访问
        * protected 受保护的，只有自身以及其父类和子类可以访问
        */
        
        public $cpu='amd';
        private $motherboard='华硕主板';
        protected $memory='海盗船';
        
        /**
        * 类属性的访问控制
        * public 公有的 可以在任何地方被调用 
        * private 私有的，只有自身可以调用
        * protected 受保护的，只有自身以及其父类和子类可以调用
        */
        
        //
        public function getCPU(){
            //在类的内部，通过$this关键字访问属性，$this表示当前实例，指向当前对象本身
            return $this->cpu;
        }
        
        public function showCPU(){
            //在类的内部，通过$this关键字调用方法
            echo 'CPU型号:'.$this->getCPU();
        }
        
        //析构方法，对象被销毁时会调用的方法
        public function __destruct(){
            echo '对象被销毁时调用了析构方法';
        }
        
        
    }
    //使用new关键字生成对象
    $computer=new Computer();
    
    var_dump($computer->getCPU());
    $computer->showCPU();
```



## 类的常量

使用const关键字定义常量，一般采用大写和下划线的方式命名。常量是属于类的，不是属于对象的。。通常使用self关键字来访问类的静态成员、方法和常量，self表示类本身，指向当前的类，在类的内部方法访问已经声明为const及static的属性时，需要使用self::$name的形式

```php
<?php
    //定义一个类
    class Computer {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        
        public function getSys(){
            echo '操作系统为：'.self::SYS;
        }
        
    }
    //使用new关键字生成对象
    $computer=new Computer();
    $computer->getSys();

```

运行结果：

```bash
类初始化，执行构造方法操作系统为：windows
```





## 类的继承

PHP通过extends关键字实现继承

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        
        public function getSys(){
            echo '操作系统为：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
        
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();
```



调用父类的private方法或者属性

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        
        private function getSys(){
            echo '操作系统为：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
        
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();

```

运行结果：

```bash
类初始化，执行构造方法
Fatal error: Uncaught Error: Call to private method Computer::getSys() from context '' in C:\php_learn\sample\2.php:28
Stack trace:
#0 {main}
  thrown in C:\php_learn\sample\2.php on line 28

```

因为private 属性或者方法只有类本身可以访问，所以在外部调用父类的私有方法会报错

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        public function getSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
        
        private function privateGetSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
        protected function protectedGetSys(){
            echo '受保护的方法获取操作系统：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
        public function testPrivate(){
            $this->privateGetSys();
        }
        
        public function testProtected(){
            $this->protectedGetSys();
        }
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();
    $pc->testProtected();
    $pc->testPrivate();
    

```

运行结果：

```bash
类初始化，执行构造方法私有方法获取操作系统：windows受保护的方法获取操作系统：windows
Fatal error: Uncaught Error: Call to private method Computer::privateGetSys() from context 'PC' in C:\php_learn\sample\2.p
hp:32
Stack trace:
#0 C:\php_learn\sample\2.php(44): PC->testPrivate()
#1 {main}
  thrown in C:\php_learn\sample\2.php on line 32

```

可以看出父类的public方法可以被子类和外部调用，protected方法可以被子类调用，但是不能被外部调用，private的则只能被自身调用。

子类和父类具有同名方法时，子类调用该方法时使用的是自身的方法，实现了子类对父类方法的重写。

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '类初始化，执行构造方法';
        }
        
        public function getSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
        
       
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
       
        public function getSys(){
            echo '子类覆盖了父类的方法';
        }
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();
```

运行结果：

```bash
类初始化，执行构造方法子类覆盖了父类的方法
```

使用parent关键字调用父类方法

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '父类初始化，执行构造方法';
        }
        
        public function getSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
       
        public function __construct(){
            parent::__construct();
            echo '子类初始化，执行构造方法';
        }
       
        public function getSys(){
            echo '子类覆盖了父类的方法';
        }
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();
```



## final关键字

如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承

```php
<?php
    //定义一个类
    final class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '父类初始化，执行构造方法';
        }
        
        public function getSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
       
        public function __construct(){
            parent::__construct();
            echo '子类初始化，执行构造方法';
        }
       
        public function getSys(){
            echo '子类覆盖了父类的方法';
        }
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();

```

运行结果：

```bash
Fatal error: Class PC may not inherit from final class (Computer) in C:\php_learn\sample\2.php on line 31
```



或者对类的方法设置final，防止方法被重写

```php
<?php
    //定义一个类
    class Computer 
    {
        
        const SYS='windows';
        
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo '父类初始化，执行构造方法';
        }
        
        final public function getSys(){
            echo '私有方法获取操作系统：'.self::SYS;
        }
        
    }
    
    //通过extends关键字继承Computer类
    class PC extends Computer 
    {
       
        public function __construct(){
            //通过
            parent::__construct();
            echo '子类初始化，执行构造方法';
        }
       
        public function getSys(){
            echo '子类覆盖了父类的方法';
        }
    }
    
    //使用new关键字生成对象
    $pc=new PC();
    $pc->getSys();
```

运行结果：

```bash
Fatal error: Cannot override final method Computer::getSys() in C:\php_learn\sample\2.php on line 31
```

## 命名空间 namespace

PHP 使用namespace（命名空间）来解决Class重名的问题

1.php

```php
<?php
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'mac 类初始化，执行构造方法';
        }
    }
```

2.php

```php
<?php
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'windows 类初始化，执行构造方法';
        }
    }
```

namespce.php

```php
<?php
    require('1.php');
    require('2.php');
    
    new Computer();
```



运行结果：

```bash
Fatal error: Cannot declare class mac\Computer, because the name is already in use in C:\php_learn\samp
le\2.php on line 4
```

在PHP文件头部添加namespace 区分不同的类，命名空间不同层级使用\进行分隔,调用时使用namespace调用

```php
<?php
    namespace mac;
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'mac 类初始化，执行构造方法';
        }
    }
```

```php
<?php
    namespace windows\windowsXP;
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'windows 类初始化，执行构造方法';
        }
    }
```

namespace.php

```php
<?php
    require('1.php');
    require('2.php');
    //命名空间不同层级采用\进行区分
    new windows\windowsXP\Computer();
    new mac\Computer();
```

不仅仅是Class支持命名空间，函数、const定义的常量等也支持命名空间

1.php

```php
<?php 
    namespace mac;
    function showSys(){
          echo '我是1.php';
     }
```

2.php

```php
<?php 
	namespace windows;
    function showSys(){
          echo '我是2.php';
     }
```

```php
<?php
    require('1.php');
    require('2.php');
    //命名空间不同层级采用\进行区分
    windows\windowsXP\showSys();
    mac\showSys();
```

如果命名空间层级太多或者名称太长，使用起来很不方便，我们可以使用use关键字导入类，使用as关键字对命名空间重命名

1.php

```php
<?php
    namespace Apple\mac\Macintosh;
    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'mac 类初始化，执行构造方法';
        }
    }
```

2.php

```php
<?php
    namespace Microsoft\windows\windowsXP;

    //定义一个类
    class Computer{
        //构造方法，类实例化时会自动执行的方法
        public function __construct(){
            echo 'windows 类初始化，执行构造方法';
        }
    }

```



namespace.php

```php
<?php
    require('1.php');
    require('2.php');
    //导入类并命名
    use Microsoft\windows\windowsXP\Computer as windows;
    use Apple\mac\Macintosh\Computer as mac;
    
    new windows();
    new mac();
```

对函数和常量使用use需要添加function、const关键字

1.php

```php
<?php
    namespace Apple\mac;
    
    function showSys(){
        echo '我是mac电脑';
    }
```

2.php

```php
<?php
    namespace Microsoft\windows;

    function showSys(){
        echo '我是windows电脑';
    }

```

namespace.php

```php
<?php
    require('1.php');
    require('2.php');
    //导入函数并命名
    use function Microsoft\windows\showSys as showWindows;
    use function Apple\mac\showSys as showMac;
    
    showWindows();
    showMac();
```

运行结果：

```bash
$ php namespace.php
我是windows电脑我是mac电脑
```



如果不添加function 关键字运行：

```bash
Fatal error: Uncaught Error: Call to undefined function showWindows() in C:\php_learn\sample\na
mespace.php:8
Stack trace:
#0 {main}
  thrown in C:\php_learn\sample\namespace.php on line 8
```

如果在有namespace的文件中调用全局空间下的Class，会在当前命名空间下徐州，为了解决这个问题，可以通过调用时添加一个\规避。

```php
<?php
    namespace main;
	//添加一个\ 避免调用当前命名空间下的类
	new \testClass();
```

如果是函数和常量，会在当前命名空间下不存在对应的常量和函数的时候，会自动去全局空间下寻找，也可以通过此种方式解决。





## 自动加载类

PHP提供了两个方法来处理每次都要手动加载类文件的问题。分别是__autoload方法和spl_autoload_register

当函数使用没有当前空间中引入或注册的Class时，如果有__autload函数会默认调用该函数。

mac.php

```php
<?php
	//定义mac类
    Class mac {
        public function __construct(){
            echo 'Mac类';
        }
    }
```

windows.php

```php
<?php
	//定义windows类
    Class windows {
        public function __construct(){
            echo 'Windows类';
        }
    }
```

autoload.php

```php
<?php
    //注册autoload函数，用来加载类
    function __autoload($className){
        require $className.'.php';
    }
    
    new windows();
    
    new mac();
```



PHP官方推荐使用spl_autoload_register函数来实现任意数量的加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。

spl_autoload_register支持匿名函数，函数名，Class的方法作为加载器

匿名函数作为参数



```php
<?php
    //注册匿名函数作为加载器
    spl_autoload_register(function($className){
        require $className.'.php';
    });
    
    new windows();
    
    new mac();
```

函数名作为参数

```php
<?php
    //注册加载器函数
    function loader($className){
        require_once($className.'.php');
    }
    //传入函数名作为参数
    spl_autoload_register('loader');
    
    new windows();
    
    new mac();
```

使用Class相关的方法以数组形式传入参数作为加载器

```php
<?php
    //定义加载器类
    Class AutoLoader{
        //注册加载方法
        public function load($className){
            require_once($className.'.php');
        }
    }
    
    //传入[类名,方法名]作为参数
    spl_autoload_register([new AutoLoader,'load']);
    
    new windows();
    
    new mac();
```



实践中我们通常使用命名空间+类名等于文件路径的方式来组织类文件



systems/microsoft/windows.php

```php
<?php
    namespace systems\microsoft;
    
    Class windows{
        public function showSys(){
            echo "我是自动加载的windows类 \r\n";
        }
    }
    
```

systems/apple/mac.php

```php
<?php
    namespace systems\apple;
    
    Class mac{
        public function showSys(){
            echo "我是自动加载的mac类 \r\n";
        }
    }
    
```

load_mod.php

```php
<?php
    //定义加载器类
    Class AutoLoader {
        //注册加载方法
        public function load($className){
            //将命名空间的\替换成/ 映射为真实的类文件路径
            $classFilePath=str_replace("\\",'/',$className.'.php');
            require_once($classFilePath);
        }
    }
    
    //传入[类名,方法名]作为参数
    spl_autoload_register([new AutoLoader,'load']);
    
    $win=new systems\microsoft\windows();
    
    $mac=new systems\apple\mac();
    
    $win->showSys();
    $mac->showSys();
```

运行结果：

```bash
$ php load_mod.php
我是自动加载的windows类
我是自动加载的mac类
```

##  Static（静态）关键字

声明类属性或方法为静态，可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。

```php
<?php
    Class Computer{
        public static $memory='Samsung';
        public static $harddrive='Kingston';
    }

    echo (Computer::$memory);
 	$pc=new Computer();
    echo $pc->memory;

```



由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。

```php
<?php
    Class Computer{
        public static $memory='Samsung';
        public static $harddrive='Kingston';
        
        public static function showDevice(){
            echo $this->memory;
        }
    }
    
    $pc=new Computer();
    $pc->showDevice();


```

输出结果：

```bash
Fatal error: Uncaught Error: Using $this when not in object context in C:\php_learn\sample\st
atic.php:7
Stack trace:
#0 C:\php_learn\sample\static.php(12): Computer::showDevice()
#1 {main}
  thrown in C:\php_learn\sample\static.php on line 7

```



静态属性不可以由对象通过 -> 操作符来访问。

```php
<?php
    Class Computer{
        public static $memory='Samsung';
        public static $harddrive='Kingston';
        
        public static function showDevice(){
            echo self::$memory;
        }
    }
    
    $pc=new Computer();
    $pc->showDevice();
```



用静态方式调用一个非静态方法会导致一个 **`E_STRICT`** 级别的错误。

就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。

调用父类的静态属性或者方法时，使用parent关键字

```php
<?php
    Class Computer{
        public static $memory='Samsung';
        public static $harddrive='Kingston';
        
        public static function showDevice(){
            echo self::$memory;
        }
    }
    
    //继承Computer类
    Class Windows extends Computer{
        public function showMemory(){
            //调用父类静态方法
            return parent::showDevice();
        }
    }
    
    
    $pc=new Windows();
    $pc->showMemory();
```





